{"version":3,"file":"index.cjs","sources":["../src/fsrs/models.ts","../src/fsrs/help.ts","../src/fsrs/scheduler.ts","../src/fsrs/default.ts","../src/fsrs/algorithm.ts","../src/fsrs/fsrs.ts"],"sourcesContent":["export type StateType = \"New\" | \"Learning\" | \"Review\" | \"Relearning\";\n\nexport enum State {\n  New = 0,\n  Learning = 1,\n  Review = 2,\n  Relearning = 3,\n}\n\nexport type RatingType = \"Manual\" | \"Again\" | \"Hard\" | \"Good\" | \"Easy\";\n\nexport enum Rating {\n  Manual = 0,\n  Again = 1,\n  Hard = 2,\n  Good = 3,\n  Easy = 4,\n}\n\ntype ExcludeManual<T> = Exclude<T, Rating.Manual>;\n\nexport type Grade = ExcludeManual<Rating>;\n\nexport interface ReviewLog {\n  rating: Rating; // Rating of the review (Again, Hard, Good, Easy)\n  state: State; // State of the review (New, Learning, Review, Relearning)\n  due: Date;  // Date of the last scheduling\n  stability: number; // Memory stability during the review\n  difficulty: number; // Difficulty of the card during the review\n  elapsed_days: number; // Number of days elapsed since the last review\n  last_elapsed_days: number; // Number of days between the last two reviews\n  scheduled_days: number; // Number of days until the next review\n  review: Date; // Date of the review\n}\n\nexport type RecordLogItem = {\n  card: Card;\n  log: ReviewLog;\n};\nexport type RecordLog = {\n  [key in Grade]: RecordLogItem;\n};\n\nexport interface Card {\n  due: Date; // Due date\n  stability: number; // Stability\n  difficulty: number; // Difficulty level\n  elapsed_days: number; // Number of days elapsed\n  scheduled_days: number; // Number of days scheduled\n  reps: number; // Repetition count\n  lapses: number; // Number of lapses or mistakes\n  state: State; // Card's state (New, Learning, Review, Relearning)\n  last_review?: Date; // Date of the last review (optional)\n}\n\nexport interface CardInput extends Omit<Card, \"state\" | \"due\" | \"last_review\"> {\n  state: StateType | State; // Card's state (New, Learning, Review, Relearning)\n  due: DateInput; // Due date\n  last_review?: DateInput | null; // Date of the last review (optional)\n}\n\nexport type DateInput = Date | number | string;\n\nexport interface ReviewLogInput\n  extends Omit<ReviewLog, \"rating\" | \"state\" | \"due\" | \"review\"> {\n  rating: RatingType | Rating; // Rating of the review (Again, Hard, Good, Easy)\n  state: StateType | State; // Card's state (New, Learning, Review, Relearning)\n  due: DateInput; // Due date\n  review: DateInput; // Date of the last review\n}\n\nexport interface FSRSParameters {\n  request_retention: number;\n  maximum_interval: number;\n  w: number[];\n  enable_fuzz: boolean;\n}\n\nexport type RescheduleOptions = {\n  enable_fuzz?: boolean;\n  dateHandler?: (date: Date) => DateInput;\n};","import type { int, unit } from \"./type\";\nimport type { DateInput, Grade } from './models';\nimport { Rating, State } from './models';\n\ndeclare global {\n  export interface Date {\n    scheduler(t: int, isDay?: boolean): Date;\n\n    diff(pre: Date, unit: unit): int;\n\n    format(): string;\n\n    dueFormat(last_review: Date, unit?: boolean,timeUnit?: string[]): string;\n  }\n}\n\nDate.prototype.scheduler = function (t: int, isDay?: boolean): Date {\n  return date_scheduler(this, t, isDay);\n};\n\n/**\n * 当前时间与之前的时间差值\n * @param pre 比当前时间还要之前\n * @param unit 单位: days | minutes\n */\nDate.prototype.diff = function (pre: Date, unit: unit): int {\n  return date_diff(this, pre, unit) as int;\n};\n\nDate.prototype.format = function (): string {\n  return formatDate(this);\n};\n\nDate.prototype.dueFormat = function (last_review: Date, unit?: boolean,timeUnit?: string[]) {\n  return show_diff_message(this, last_review, unit, timeUnit);\n};\n\n/**\n * 计算日期和时间的偏移，并返回一个新的日期对象。\n * @param now 当前日期和时间\n * @param t 时间偏移量，当 isDay 为 true 时表示天数，为 false 时表示分钟\n * @param isDay （可选）是否按天数单位进行偏移，默认为 false，表示按分钟单位计算偏移\n * @returns 偏移后的日期和时间对象\n */\nexport function date_scheduler(now: DateInput, t: number, isDay?: boolean): Date {\n  return new Date(\n    isDay\n      ? fixDate(now).getTime() + t * 24 * 60 * 60 * 1000\n      : fixDate(now).getTime() + t * 60 * 1000,\n  );\n}\n\nexport function date_diff(now: DateInput, pre: DateInput, unit: unit): number {\n  if (!now || !pre) {\n    throw new Error(\"Invalid date\");\n  }\n  const diff = fixDate(now).getTime() - fixDate(pre).getTime();\n  let r = 0;\n  switch (unit) {\n    case \"days\":\n      r = Math.floor(diff / (24 * 60 * 60 * 1000));\n      break;\n    case \"minutes\":\n      r = Math.floor(diff / (60 * 1000));\n      break;\n  }\n  return r;\n}\n\nexport function formatDate(dateInput: DateInput): string {\n  const date = fixDate(dateInput);\n  const year: number = date.getFullYear();\n  const month: number = date.getMonth() + 1;\n  const day: number = date.getDate();\n  const hours: number = date.getHours();\n  const minutes: number = date.getMinutes();\n  const seconds: number = date.getSeconds();\n\n  return `${year}-${padZero(month)}-${padZero(day)} ${padZero(hours)}:${padZero(\n    minutes,\n  )}:${padZero(seconds)}`;\n}\n\nfunction padZero(num: number): string {\n  return num < 10 ? `0${num}` : `${num}`;\n}\n\nconst TIMEUNIT = [60, 60, 24, 31, 12];\nconst TIMEUNITFORMAT = [\"second\", \"min\", \"hour\", \"day\", \"month\", \"year\"];\n\nexport function show_diff_message(\n  due: DateInput,\n  last_review: DateInput,\n  unit?: boolean,\n  timeUnit: string[] = TIMEUNITFORMAT,\n): string {\n  due = fixDate(due);\n  last_review = fixDate(last_review);\n  if (timeUnit.length !== TIMEUNITFORMAT.length) {\n    timeUnit = TIMEUNITFORMAT;\n  }\n  let diff = due.getTime() - last_review.getTime();\n  let i;\n  diff /= 1000;\n  for (i = 0; i < TIMEUNIT.length; i++) {\n    if (diff < TIMEUNIT[i]) {\n      break;\n    } else {\n      diff /= TIMEUNIT[i];\n    }\n  }\n  return `${Math.floor(diff)}${unit ? timeUnit[i] : \"\"}`;\n}\n\nexport function fixDate(value: unknown) {\n  if (typeof value === \"object\" && value instanceof Date) {\n    return value;\n  } else if (typeof value === \"string\") {\n    const timestamp = Date.parse(value);\n    if (!isNaN(timestamp)) {\n      return new Date(timestamp);\n    } else {\n      throw new Error(`Invalid date:[${value}]`);\n    }\n  } else if (typeof value === \"number\") {\n    return new Date(value);\n  }\n  throw new Error(`Invalid date:[${value}]`);\n}\n\nexport function fixState(value: unknown): State {\n  if (typeof value === \"string\") {\n    const firstLetter = value.charAt(0).toUpperCase();\n    const restOfString = value.slice(1).toLowerCase();\n    const ret= State[`${firstLetter}${restOfString}` as keyof typeof State]\n    if(ret === undefined){\n      throw new Error(`Invalid state:[${value}]`);\n    }\n    return ret;\n  } else if (typeof value === \"number\") {\n    return value as State;\n  }\n  throw new Error(`Invalid state:[${value}]`);\n}\n\nexport function fixRating(value: unknown): Rating {\n  if (typeof value === \"string\") {\n    const firstLetter = value.charAt(0).toUpperCase();\n    const restOfString = value.slice(1).toLowerCase();\n    const ret = Rating[`${firstLetter}${restOfString}` as keyof typeof Rating]\n    if(ret === undefined){\n      throw new Error(`Invalid rating:[${value}]`);\n    }\n    return ret;\n  } else if (typeof value === \"number\") {\n    return value as Rating;\n  }\n  throw new Error(`Invalid rating:[${value}]`);\n}\n\n\nexport const Grades: Readonly<Grade[]> = [Rating.Again, Rating.Hard, Rating.Good, Rating.Easy] as const;\n\nconst FUZZ_RANGES = [\n  {\n    start: 2.5,\n    end: 7.0,\n    factor: 0.15,\n  },\n  {\n    start: 7.0,\n    end: 20.0,\n    factor: 0.1,\n  },\n  {\n    start: 20.0,\n    end: Infinity,\n    factor: 0.05,\n  },\n] as const;\n\nexport function get_fuzz_range(\n  interval: number,\n  elapsed_days: number,\n  maximum_interval: number,\n) {\n  let delta = 1.0;\n  for (const range of FUZZ_RANGES) {\n    delta +=\n      range.factor * Math.max(Math.min(interval, range.end) - range.start, 0.0);\n  }\n  interval = Math.min(interval, maximum_interval);\n  let min_ivl = Math.max(2, Math.round(interval - delta));\n  const max_ivl = Math.min(Math.round(interval + delta), maximum_interval);\n  if (interval > elapsed_days) {\n    min_ivl = Math.max(min_ivl, elapsed_days + 1);\n  }\n  min_ivl = Math.min(min_ivl, max_ivl);\n  return { min_ivl, max_ivl };\n}\n","import { Card, Rating, RecordLog, State } from \"./models\";\nimport { date_scheduler } from \"./help\";\n\nexport class SchedulingCard {\n  again: Card;\n  hard: Card;\n  good: Card;\n  easy: Card;\n  last_review: Date;\n  last_elapsed_days: number;\n\n  private copy(card: Card): Card {\n    return {\n      ...card,\n    };\n  }\n\n  constructor(card: Card, now: Date) {\n    this.last_review = card.last_review || card.due;\n    this.last_elapsed_days = card.elapsed_days;\n    card.elapsed_days =\n      card.state === State.New ? 0 : now.diff(card.last_review as Date, \"days\"); //相距时间\n    card.last_review = now; // 上次复习时间\n    card.reps += 1;\n    this.again = this.copy(card);\n    this.hard = this.copy(card);\n    this.good = this.copy(card);\n    this.easy = this.copy(card);\n  }\n\n  update_state(state: State) {\n    if (state === State.New) {\n      this.again.state = State.Learning;\n      this.hard.state = State.Learning;\n      this.good.state = State.Learning;\n      this.easy.state = State.Review;\n    } else if (state === State.Learning || state === State.Relearning) {\n      this.again.state = state;\n      this.hard.state = state;\n      this.good.state = State.Review;\n      this.easy.state = State.Review;\n    } else if (state === State.Review) {\n      this.again.state = State.Relearning;\n      this.hard.state = State.Review;\n      this.good.state = State.Review;\n      this.easy.state = State.Review;\n      this.again.lapses += 1;\n    }\n    return this;\n  }\n\n  schedule(\n    now: Date,\n    hard_interval: number,\n    good_interval: number,\n    easy_interval: number,\n  ): SchedulingCard {\n    this.again.scheduled_days = 0;\n    this.hard.scheduled_days = hard_interval;\n    this.good.scheduled_days = good_interval;\n    this.easy.scheduled_days = easy_interval;\n    this.again.due = date_scheduler(now, 5);\n    this.hard.due =\n      hard_interval > 0\n        ? date_scheduler(now, hard_interval, true)\n        : date_scheduler(now, 10);\n    this.good.due = date_scheduler(now, good_interval, true);\n    this.easy.due = date_scheduler(now, easy_interval, true);\n    return this;\n  }\n\n  record_log(card: Card, now: Date): RecordLog {\n    return {\n      [Rating.Again]: {\n        card: this.again,\n        log: {\n          rating: Rating.Again,\n          state: card.state,\n          due: this.last_review,\n          stability: card.stability,\n          difficulty: card.difficulty,\n          elapsed_days: card.elapsed_days,\n          last_elapsed_days: this.last_elapsed_days,\n          scheduled_days: card.scheduled_days,\n          review: now,\n        },\n      },\n      [Rating.Hard]: {\n        card: this.hard,\n        log: {\n          rating: Rating.Hard,\n          state: card.state,\n          due: this.last_review,\n          stability: card.stability,\n          difficulty: card.difficulty,\n          elapsed_days: card.elapsed_days,\n          last_elapsed_days: this.last_elapsed_days,\n          scheduled_days: card.scheduled_days,\n          review: now,\n        },\n      },\n      [Rating.Good]: {\n        card: this.good,\n        log: {\n          rating: Rating.Good,\n          state: card.state,\n          due: this.last_review,\n          stability: card.stability,\n          difficulty: card.difficulty,\n          elapsed_days: card.elapsed_days,\n          last_elapsed_days: this.last_elapsed_days,\n          scheduled_days: card.scheduled_days,\n          review: now,\n        },\n      },\n      [Rating.Easy]: {\n        card: this.easy,\n        log: {\n          rating: Rating.Easy,\n          state: card.state,\n          due: this.last_review,\n          stability: card.stability,\n          difficulty: card.difficulty,\n          elapsed_days: card.elapsed_days,\n          last_elapsed_days: this.last_elapsed_days,\n          scheduled_days: card.scheduled_days,\n          review: now,\n        },\n      },\n    };\n  }\n}\n","import { Card, DateInput, FSRSParameters, State } from \"./models\";\nimport { fixDate } from \"./help\";\n\nexport const default_request_retention = 0.95;\nexport const default_maximum_interval = 36500;\nexport const default_w = [\n  0.5701, 1.4436, 4.1386, 10.9355, 5.1443, 1.2006, 0.8627, 0.0362, 1.629,\n  0.1342, 1.0166, 2.1174, 0.0839, 0.3204, 1.4676, 0.219, 2.8237,\n];\nexport const default_enable_fuzz = true;\n\nexport const FSRSVersion: string = \"3.5.3\";\n\nexport const generatorParameters = (\n  props?: Partial<FSRSParameters>,\n): FSRSParameters => {\n  return {\n    request_retention: props?.request_retention || default_request_retention,\n    maximum_interval: props?.maximum_interval || default_maximum_interval,\n    w: props?.w || default_w,\n    enable_fuzz: props?.enable_fuzz || default_enable_fuzz,\n  };\n};\n\n/**\n * Create an empty card\n * @param now Current time\n * @param afterHandler Convert the result to another type. (Optional)\n * @example\n * ```\n * const card: Card = createEmptyCard(new Date());\n * ```\n * @example\n * ```\n * interface CardUnChecked\n *   extends Omit<Card, \"due\" | \"last_review\" | \"state\"> {\n *   cid: string;\n *   due: Date | number;\n *   last_review: Date | null | number;\n *   state: StateType;\n * }\n *\n * function cardAfterHandler(card: Card) {\n *      return {\n *       ...card,\n *       cid: \"test001\",\n *       state: State[card.state],\n *       last_review: card.last_review ?? null,\n *     } as CardUnChecked;\n * }\n *\n * const card: CardUnChecked = createEmptyCard(new Date(), cardAfterHandler);\n * ```\n */\nexport function createEmptyCard<R = Card>(\n  now?: DateInput,\n  afterHandler?: (card: Card) => R,\n): R {\n  const emptyCard: Card = {\n    due: now ? fixDate(now) : new Date(),\n    stability: 0,\n    difficulty: 0,\n    elapsed_days: 0,\n    scheduled_days: 0,\n    reps: 0,\n    lapses: 0,\n    state: State.New,\n    last_review: undefined,\n  };\n  if (afterHandler && typeof afterHandler === \"function\") {\n    return afterHandler(emptyCard);\n  } else {\n    return emptyCard as R;\n  }\n}\n","import pseudorandom from \"seedrandom\";\nimport { generatorParameters } from \"./default\";\nimport {SchedulingCard} from './scheduler'\nimport {FSRSParameters, Grade, Rating} from \"./models\";\nimport type { int } from \"./type\";\nimport { get_fuzz_range } from \"./help\";\n\n// Ref: https://github.com/open-spaced-repetition/fsrs4anki/wiki/The-Algorithm#fsrs-v4\nexport const DECAY: number = -0.5;\n// FACTOR = Math.pow(0.9, 1 / DECAY) - 1\nexport const FACTOR: number = 19 / 81;\n\nexport class FSRSAlgorithm {\n  protected param: FSRSParameters;\n  private readonly intervalModifier: number;\n  protected seed?: string;\n\n  constructor(param: Partial<FSRSParameters>) {\n    this.param = generatorParameters(param);\n    // Ref: https://github.com/open-spaced-repetition/fsrs4anki/wiki/The-Algorithm#fsrs-45\n    // The formula used is : I(r,s)= (r^{\\frac{1}{DECAY}-1}) \\times \\frac{s}{FACTOR}\n    this.intervalModifier =\n      (Math.pow(this.param.request_retention, 1 / DECAY) - 1) / FACTOR;\n  }\n\n  init_ds(s: SchedulingCard): void {\n    s.again.difficulty = this.init_difficulty(Rating.Again);\n    s.again.stability = this.init_stability(Rating.Again);\n    s.hard.difficulty = this.init_difficulty(Rating.Hard);\n    s.hard.stability = this.init_stability(Rating.Hard);\n    s.good.difficulty = this.init_difficulty(Rating.Good);\n    s.good.stability = this.init_stability(Rating.Good);\n    s.easy.difficulty = this.init_difficulty(Rating.Easy);\n    s.easy.stability = this.init_stability(Rating.Easy);\n  }\n\n  /**\n   * Updates the difficulty and stability values of the scheduling card based on the last difficulty,\n   * last stability, and the current retrievability.\n   * @param {SchedulingCard} s scheduling Card\n   * @param {number} last_d Difficulty\n   * @param {number} last_s Stability\n   * @param retrievability Retrievability\n   */\n  next_ds(\n    s: SchedulingCard,\n    last_d: number,\n    last_s: number,\n    retrievability: number,\n  ): void {\n    s.again.difficulty = this.next_difficulty(last_d, Rating.Again);\n    s.again.stability = this.next_forget_stability(\n      last_d,\n      last_s,\n      retrievability,\n    );\n    s.hard.difficulty = this.next_difficulty(last_d, Rating.Hard);\n    s.hard.stability = this.next_recall_stability(\n      last_d,\n      last_s,\n      retrievability,\n      Rating.Hard,\n    );\n    s.good.difficulty = this.next_difficulty(last_d, Rating.Good);\n    s.good.stability = this.next_recall_stability(\n      last_d,\n      last_s,\n      retrievability,\n      Rating.Good,\n    );\n    s.easy.difficulty = this.next_difficulty(last_d, Rating.Easy);\n    s.easy.stability = this.next_recall_stability(\n      last_d,\n      last_s,\n      retrievability,\n      Rating.Easy,\n    );\n  }\n\n  /**\n   * The formula used is :\n   * S_0(G) = w_{G-1}\n   * \\max \\{S_0,0.1\\}\n   * @param g Grade (rating at Anki) [1.again,2.hard,3.good,4.easy]\n   * @return Stability (interval when R=90%)\n   */\n  init_stability(g: Grade): number {\n    return Math.max(this.param.w[g - 1], 0.1);\n  }\n\n  /**\n   * The formula used is :\n   * $$D_0(G) = w_4 - (G-3) \\cdot w_5$$\n   * $$\\min \\{\\max \\{D_0(G),1\\},10\\}$$\n   * where the D_0(3)=w_4 when the first rating is good.\n   * @param {Grade} g Grade (rating at Anki) [1.again,2.hard,3.good,4.easy]\n   * @return {number} Difficulty D \\in [1,10]\n   */\n  init_difficulty(g: Grade): number {\n    return +Math.min(\n      Math.max(this.param.w[4] - (g - 3) * this.param.w[5], 1),\n      10,\n    ).toFixed(8);\n  }\n\n  /**\n   * If fuzzing is disabled or ivl is less than 2.5, it returns the original interval.\n   * @param {number} ivl - The interval to be fuzzed.\n   * @param {number} elapsed_days t days since the last review\n   * @param {number} enable_fuzz - This adds a small random delay to the new interval time to prevent cards from sticking together and always being reviewed on the same day.\n   * @return {number} - The fuzzed interval.\n   **/\n  apply_fuzz(ivl: number, elapsed_days: number, enable_fuzz?: boolean): int {\n    if (!enable_fuzz || ivl < 2.5) return Math.round(ivl) as int;\n    const generator = pseudorandom(this.seed);\n    const fuzz_factor = generator();\n    const { min_ivl, max_ivl } = get_fuzz_range(\n      ivl,\n      elapsed_days,\n      this.param.maximum_interval,\n    );\n    return Math.floor(fuzz_factor * (max_ivl - min_ivl + 1) + min_ivl) as int;\n  }\n\n  /**\n   *  Ref:\n   *   constructor(param: Partial<FSRSParameters>)\n   *   this.intervalModifier = 9 * (1 / this.param.request_retention - 1);\n   *   @param {number} s - Stability (interval when R=90%)\n   *   @param {number} elapsed_days t days since the last review\n   *   @param {number} enable_fuzz - This adds a small random delay to the new interval time to prevent cards from sticking together and always being reviewed on the same day.\n   */\n  next_interval(\n    s: number,\n    elapsed_days: number,\n    enable_fuzz: boolean = this.param.enable_fuzz,\n  ): int {\n    const newInterval = Math.min(\n      Math.max(1, Math.round(s * this.intervalModifier)),\n      this.param.maximum_interval,\n    ) as int;\n    return this.apply_fuzz(newInterval, elapsed_days, enable_fuzz);\n  }\n\n  /**\n   * The formula used is :\n   * $$next_d = D - w_6 \\cdot (R - 2)$$\n   * $$D^\\prime(D,R) = w_5 \\cdot D_0(2) +(1 - w_5) \\cdot next_d$$\n   * @param {number} d Difficulty D \\in [1,10]\n   * @param {Grade} g Grade (rating at Anki) [1.again,2.hard,3.good,4.easy]\n   * @return {number} next_D\n   */\n  next_difficulty(d: number, g: Grade): number {\n    const next_d = d - this.param.w[6] * (g - 3);\n    return this.constrain_difficulty(\n      this.mean_reversion(this.param.w[4], next_d),\n    );\n  }\n\n  /**\n   * The formula used is :\n   * $$\\min \\{\\max \\{D_0,1\\},10\\}$$\n   * @param {number} difficulty D \\in [1,10]\n   */\n  constrain_difficulty(difficulty: number): number {\n    return Math.min(Math.max(+difficulty.toFixed(8), 1), 10);\n  }\n\n  /**\n   * The formula used is :\n   * $$w_7 \\cdot init +(1 - w_7) \\cdot current$$\n   * @param {number} init $$w_2 : D_0(3) = w_2 + (R-2) \\cdot w_3= w_2$$\n   * @param {number} current $$D - w_6 \\cdot (R - 2)$$\n   * @return {number} difficulty\n   */\n  mean_reversion(init: number, current: number): number {\n    return +(this.param.w[7] * init + (1 - this.param.w[7]) * current).toFixed(\n      8,\n    );\n  }\n\n  /**\n   * The formula used is :\n   * $$S^\\prime_r(D,S,R,G) = S\\cdot(e^{w_8}\\cdot (11-D)\\cdot S^{-w_9}\\cdot(e^{w_10\\cdot(1-R)}-1)\\cdot w_15(if G=2) \\cdot w_16(if G=4)+1)$$\n   * @param {number} d Difficulty D \\in [1,10]\n   * @param {number} s Stability (interval when R=90%)\n   * @param {number} r Retrievability (probability of recall)\n   * @param {Grade} g Grade (Rating[0.again,1.hard,2.good,3.easy])\n   * @return {number} S^\\prime_r new stability after recall\n   */\n  next_recall_stability(d: number, s: number, r: number, g: Grade): number {\n    const hard_penalty = Rating.Hard === g ? this.param.w[15] : 1;\n    const easy_bound = Rating.Easy === g ? this.param.w[16] : 1;\n    return +(\n      s *\n      (1 +\n        Math.exp(this.param.w[8]) *\n          (11 - d) *\n          Math.pow(s, -this.param.w[9]) *\n          (Math.exp((1 - r) * this.param.w[10]) - 1) *\n          hard_penalty *\n          easy_bound)\n    ).toFixed(8);\n  }\n\n  /**\n   * The formula used is :\n   * $$S^\\prime_f(D,S,R) = w_11\\cdot D^{-w_{12}}\\cdot ((S+1)^{w_{13}}-1) \\cdot e^{w_{14}\\cdot(1-R)}.$$\n   * @param {number} d Difficulty D \\in [1,10]\n   * @param {number} s Stability (interval when R=90%)\n   * @param {number} r Retrievability (probability of recall)\n   * @return {number} S^\\prime_f new stability after forgetting\n   */\n  next_forget_stability(d: number, s: number, r: number): number {\n    return +(\n      this.param.w[11] *\n      Math.pow(d, -this.param.w[12]) *\n      (Math.pow(s + 1, this.param.w[13]) - 1) *\n      Math.exp((1 - r) * this.param.w[14])\n    ).toFixed(8);\n  }\n\n  /**\n   * The formula used is :\n   * $$R(t,S) = (1 + FACTOR \\times \\frac{t}{9 \\cdot S})^{DECAY},$$\n   * @param {number} elapsed_days t days since the last review\n   * @param {number} stability Stability (interval when R=90%)\n   * @return {number} r Retrievability (probability of recall)\n   */\n  forgetting_curve(elapsed_days: number, stability: number): number {\n    return +Math.pow(1 + (FACTOR * elapsed_days) / stability, DECAY).toFixed(8);\n  }\n}\n","import { SchedulingCard } from \"./scheduler\";\nimport { date_scheduler, fixDate, fixRating, fixState } from \"./help\";\nimport {\n  Card,\n  CardInput,\n  DateInput,\n  FSRSParameters,\n  Rating,\n  RecordLog,\n  RecordLogItem,\n  RescheduleOptions,\n  ReviewLog,\n  ReviewLogInput,\n  State,\n} from \"./models\";\nimport type { int } from \"./type\";\nimport { FSRSAlgorithm } from \"./algorithm\";\n\nexport class FSRS extends FSRSAlgorithm {\n  constructor(param: Partial<FSRSParameters>) {\n    super(param);\n  }\n\n  private preProcessCard(_card: CardInput | Card): Card {\n    return {\n      ..._card,\n      state: fixState(_card.state),\n      due: fixDate(_card.due),\n      last_review: _card.last_review ? fixDate(_card.last_review) : undefined,\n    };\n  }\n\n  private preProcessDate(_date: DateInput): Date {\n    return fixDate(_date);\n  }\n\n  private preProcessLog(_log: ReviewLogInput | ReviewLog): ReviewLog {\n    return {\n      ..._log,\n      due: fixDate(_log.due),\n      rating: fixRating(_log.rating),\n      state: fixState(_log.state),\n      review: fixDate(_log.review),\n    };\n  }\n\n  /**\n   * @param card Card to be processed\n   * @param now Current time or scheduled time\n   * @param afterHandler Convert the result to another type. (Optional)\n   * @example\n   * ```\n   * const card: Card = createEmptyCard(new Date());\n   * const f = fsrs();\n   * const recordLog = f.repeat(card, new Date());\n   * ```\n   * @example\n   * ```\n   * interface RevLogUnchecked\n   *   extends Omit<ReviewLog, \"due\" | \"review\" | \"state\" | \"rating\"> {\n   *   cid: string;\n   *   due: Date | number;\n   *   state: StateType;\n   *   review: Date | number;\n   *   rating: RatingType;\n   * }\n   *\n   * interface RepeatRecordLog {\n   *   card: CardUnChecked; //see method: createEmptyCard\n   *   log: RevLogUnchecked;\n   * }\n   *\n   * function repeatAfterHandler(recordLog: RecordLog) {\n   *     const record: { [key in Grade]: RepeatRecordLog } = {} as {\n   *       [key in Grade]: RepeatRecordLog;\n   *     };\n   *     for (const grade of Grades) {\n   *       record[grade] = {\n   *         card: {\n   *           ...(recordLog[grade].card as Card & { cid: string }),\n   *           due: recordLog[grade].card.due.getTime(),\n   *           state: State[recordLog[grade].card.state] as StateType,\n   *           last_review: recordLog[grade].card.last_review\n   *             ? recordLog[grade].card.last_review!.getTime()\n   *             : null,\n   *         },\n   *         log: {\n   *           ...recordLog[grade].log,\n   *           cid: (recordLog[grade].card as Card & { cid: string }).cid,\n   *           due: recordLog[grade].log.due.getTime(),\n   *           review: recordLog[grade].log.review.getTime(),\n   *           state: State[recordLog[grade].log.state] as StateType,\n   *           rating: Rating[recordLog[grade].log.rating] as RatingType,\n   *         },\n   *       };\n   *     }\n   *     return record;\n   * }\n   * const card: Card = createEmptyCard(new Date(), cardAfterHandler); //see method:  createEmptyCard\n   * const f = fsrs();\n   * const recordLog = f.repeat(card, new Date(), repeatAfterHandler);\n   * ```\n   */\n  repeat<R = RecordLog>(\n    card: CardInput | Card,\n    now: DateInput,\n    afterHandler?: (recordLog: RecordLog) => R,\n  ): R {\n    const processedCard = this.preProcessCard(card);\n    now = this.preProcessDate(now);\n    const s = new SchedulingCard(processedCard, now).update_state(\n      processedCard.state,\n    );\n    this.seed = String(now.getTime()) + String(processedCard.reps);\n    let easy_interval, good_interval, hard_interval;\n    const interval = processedCard.elapsed_days;\n    switch (processedCard.state) {\n      case State.New:\n        this.init_ds(s);\n        s.again.due = now.scheduler(1 as int);\n        s.hard.due = now.scheduler(5 as int);\n        s.good.due = now.scheduler(10 as int);\n        easy_interval = this.next_interval(s.easy.stability, interval);\n        s.easy.scheduled_days = easy_interval;\n        s.easy.due = now.scheduler(easy_interval, true);\n        break;\n      case State.Learning:\n      case State.Relearning:\n        hard_interval = 0;\n        good_interval = this.next_interval(s.good.stability, interval);\n        easy_interval = Math.max(\n          this.next_interval(s.easy.stability, interval),\n          good_interval + 1,\n        );\n        s.schedule(now, hard_interval, good_interval, easy_interval);\n        break;\n      case State.Review: {\n        const last_d = processedCard.difficulty;\n        const last_s = processedCard.stability;\n        const retrievability = this.forgetting_curve(interval, last_s);\n        this.next_ds(s, last_d, last_s, retrievability);\n        hard_interval = this.next_interval(s.hard.stability, interval);\n        good_interval = this.next_interval(s.good.stability, interval);\n        hard_interval = Math.min(hard_interval, good_interval);\n        good_interval = Math.max(good_interval, hard_interval + 1);\n        easy_interval = Math.max(\n          this.next_interval(s.easy.stability, interval),\n          good_interval + 1,\n        );\n        s.schedule(now, hard_interval, good_interval, easy_interval);\n        break;\n      }\n    }\n    const recordLog = s.record_log(processedCard, now);\n    if (afterHandler && typeof afterHandler === \"function\") {\n      return afterHandler(recordLog);\n    } else {\n      return recordLog as R;\n    }\n  }\n\n  get_retrievability = (\n    card: CardInput | Card,\n    now: Date,\n  ): undefined | string => {\n    const processedCard = this.preProcessCard(card);\n    now = this.preProcessDate(now);\n    if (processedCard.state !== State.Review) {\n      return undefined;\n    }\n    const t = Math.max(now.diff(processedCard.last_review as Date, \"days\"), 0);\n    return (\n      (this.forgetting_curve(t, processedCard.stability) * 100).toFixed(2) + \"%\"\n    );\n  };\n\n  /**\n   *\n   * @param card Card to be processed\n   * @param log last review log\n   * @param afterHandler Convert the result to another type. (Optional)\n   * @example\n   * ```\n   * const now = new Date();\n   * const f = fsrs();\n   * const emptyCardFormAfterHandler = createEmptyCard(now);\n   * const repeatFormAfterHandler = f.repeat(emptyCardFormAfterHandler, now);\n   * const { card, log } = repeatFormAfterHandler[Rating.Hard];\n   * const rollbackFromAfterHandler = f.rollback(card, log);\n   * ```\n   *\n   * @example\n   * ```\n   * const now = new Date();\n   * const f = fsrs();\n   * const emptyCardFormAfterHandler = createEmptyCard(now, cardAfterHandler);  //see method: createEmptyCard\n   * const repeatFormAfterHandler = f.repeat(emptyCardFormAfterHandler, now, repeatAfterHandler); //see method: fsrs.repeat()\n   * const { card, log } = repeatFormAfterHandler[Rating.Hard];\n   * const rollbackFromAfterHandler = f.rollback(card, log, cardAfterHandler);\n   * ```\n   */\n  rollback<R = Card>(\n    card: CardInput | Card,\n    log: ReviewLogInput,\n    afterHandler?: (prevCard: Card) => R,\n  ): R {\n    const processedCard = this.preProcessCard(card);\n    const processedLog = this.preProcessLog(log);\n    if (processedLog.rating === Rating.Manual) {\n      throw new Error(\"Cannot rollback a manual rating\");\n    }\n    let last_due, last_review, last_lapses;\n    switch (processedLog.state) {\n      case State.New:\n        last_due = processedLog.due;\n        last_review = undefined;\n        last_lapses = 0;\n        break;\n      case State.Learning:\n      case State.Relearning:\n      case State.Review:\n        last_due = processedLog.review;\n        last_review = processedLog.due;\n        last_lapses =\n          processedCard.lapses -\n          (processedLog.rating === Rating.Again &&\n          processedLog.state === State.Review\n            ? 1\n            : 0);\n        break;\n    }\n\n    const prevCard: Card = {\n      ...processedCard,\n      due: last_due,\n      stability: processedLog.stability,\n      difficulty: processedLog.difficulty,\n      elapsed_days: processedLog.last_elapsed_days,\n      scheduled_days: processedLog.scheduled_days,\n      reps: Math.max(0, processedCard.reps - 1),\n      lapses: Math.max(0, last_lapses),\n      state: processedLog.state,\n      last_review: last_review,\n    };\n    if (afterHandler && typeof afterHandler === \"function\") {\n      return afterHandler(prevCard);\n    } else {\n      return prevCard as R;\n    }\n  }\n\n  /**\n   *\n   * @param card Card to be processed\n   * @param now Current time or scheduled time\n   * @param reset_count Should the review count information(reps,lapses) be reset. (Optional)\n   * @param afterHandler Convert the result to another type. (Optional)\n   * @example\n   * ```\n   * const now = new Date();\n   * const f = fsrs();\n   * const emptyCard = createEmptyCard(now);\n   * const scheduling_cards = f.repeat(emptyCard, now);\n   * const { card, log } = scheduling_cards[Rating.Hard];\n   * const forgetCard = f.forget(card, new Date(), true);\n   * ```\n   *\n   * @example\n   * ```\n   * interface RepeatRecordLog {\n   *   card: CardUnChecked; //see method: createEmptyCard\n   *   log: RevLogUnchecked; //see method: fsrs.repeat()\n   * }\n   *\n   * function forgetAfterHandler(recordLogItem: RecordLogItem): RepeatRecordLog {\n   *     return {\n   *       card: {\n   *         ...(recordLogItem.card as Card & { cid: string }),\n   *         due: recordLogItem.card.due.getTime(),\n   *         state: State[recordLogItem.card.state] as StateType,\n   *         last_review: recordLogItem.card.last_review\n   *           ? recordLogItem.card.last_review!.getTime()\n   *           : null,\n   *       },\n   *       log: {\n   *         ...recordLogItem.log,\n   *         cid: (recordLogItem.card as Card & { cid: string }).cid,\n   *         due: recordLogItem.log.due.getTime(),\n   *         review: recordLogItem.log.review.getTime(),\n   *         state: State[recordLogItem.log.state] as StateType,\n   *         rating: Rating[recordLogItem.log.rating] as RatingType,\n   *       },\n   *     };\n   * }\n   * const now = new Date();\n   * const f = fsrs();\n   * const emptyCardFormAfterHandler = createEmptyCard(now, cardAfterHandler); //see method:  createEmptyCard\n   * const repeatFormAfterHandler = f.repeat(emptyCardFormAfterHandler, now, repeatAfterHandler); //see method: fsrs.repeat()\n   * const { card } = repeatFormAfterHandler[Rating.Hard];\n   * const forgetFromAfterHandler = f.forget(card, date_scheduler(now, 1, true), false, forgetAfterHandler);\n   * ```\n   */\n  forget<R = RecordLogItem>(\n    card: CardInput | Card,\n    now: DateInput,\n    reset_count: boolean = false,\n    afterHandler?: (recordLogItem: RecordLogItem) => R,\n  ): R {\n    const processedCard = this.preProcessCard(card);\n    now = this.preProcessDate(now);\n    const scheduled_days =\n      processedCard.state === State.New\n        ? 0\n        : now.diff(processedCard.last_review as Date, \"days\");\n    const forget_log: ReviewLog = {\n      rating: Rating.Manual,\n      state: processedCard.state,\n      due: processedCard.due,\n      stability: processedCard.stability,\n      difficulty: processedCard.difficulty,\n      elapsed_days: 0,\n      last_elapsed_days: processedCard.elapsed_days,\n      scheduled_days: scheduled_days,\n      review: now,\n    };\n    const forget_card: Card = {\n      ...processedCard,\n      due: now,\n      stability: 0,\n      difficulty: 0,\n      elapsed_days: 0,\n      scheduled_days: 0,\n      reps: reset_count ? 0 : processedCard.reps,\n      lapses: reset_count ? 0 : processedCard.lapses,\n      state: State.New,\n      last_review: processedCard.last_review,\n    };\n    const recordLogItem: RecordLogItem = { card: forget_card, log: forget_log };\n    if (afterHandler && typeof afterHandler === \"function\") {\n      return afterHandler(recordLogItem);\n    } else {\n      return recordLogItem as R;\n    }\n  }\n\n  /**\n   *\n   * @param cards scheduled card collection\n   * @param options Reschedule options,fuzz is enabled by default.If the type of due is not Date, please implement dataHandler.\n   * @example\n   * ```typescript\n   * type CardType = Card & {\n   *     cid: number;\n   * };\n   * const reviewCard: CardType = {\n   *     cid: 1,\n   *     due: new Date(\"2024-03-17 04:43:02\"),\n   *     stability: 48.26139059062234,\n   *     difficulty: 5.67,\n   *     elapsed_days: 18,\n   *     scheduled_days: 51,\n   *     reps: 8,\n   *     lapses: 1,\n   *     state: State.Review,\n   *     last_review: new Date(\"2024-01-26 04:43:02\"),\n   * };\n   * const f = fsrs();\n   * const reschedule_cards = f.reschedule([reviewCard]);\n   * ```\n   *\n   */\n  reschedule<T extends CardInput | Card>(\n    cards: Array<T>,\n    options: RescheduleOptions = {},\n  ): Array<T> {\n    if (!Array.isArray(cards)) {\n      throw new Error(\"cards must be an array\");\n    }\n    const processedCard: T[] = [];\n    for (const card of cards) {\n      if (fixState(card.state) !== State.Review || !card.last_review) continue;\n      const scheduled_days = Math.floor(card.scheduled_days) as int;\n      const next_ivl = this.next_interval(\n        +card.stability.toFixed(2),\n        Math.round(card.elapsed_days),\n        options.enable_fuzz ?? true,\n      );\n      if (next_ivl === scheduled_days || next_ivl === 0) continue;\n\n      const processCard: T = { ...card };\n      processCard.scheduled_days = next_ivl;\n      const new_due = date_scheduler(processCard.last_review!, next_ivl, true);\n      if (options.dateHandler && typeof options.dateHandler === \"function\") {\n        processCard.due = options.dateHandler(new_due);\n      } else {\n        processCard.due = new_due;\n      }\n      processedCard.push(processCard);\n    }\n    return processedCard;\n  }\n}\n\n/**\n * Create a new instance of TS-FSRS\n * @param params FSRSParameters\n * @example\n * ```typescript\n * const f = fsrs();\n * ```\n * @example\n * ```typescript\n * const params: FSRSParameters = generatorParameters({ maximum_interval: 1000 });\n * const f = fsrs(params);\n * ```\n * @example\n * ```typescript\n * const f = fsrs({ maximum_interval: 1000 });\n * ```\n */\nexport const fsrs = (params?: Partial<FSRSParameters>) => {\n  return new FSRS(params || {});\n};"],"names":["State","t","Rating","isDay","date_scheduler","pre","unit","date_diff","formatDate","last_review","timeUnit","show_diff_message","now","fixDate","diff","r","dateInput","date","year","month","day","hours","minutes","seconds","padZero","num","TIMEUNIT","TIMEUNITFORMAT","due","value","timestamp","fixState","firstLetter","restOfString","ret","fixRating","Grades","FUZZ_RANGES","get_fuzz_range","interval","elapsed_days","maximum_interval","delta","range","min_ivl","max_ivl","SchedulingCard","card","state","hard_interval","good_interval","easy_interval","default_request_retention","default_maximum_interval","default_w","default_enable_fuzz","FSRSVersion","generatorParameters","props","createEmptyCard","afterHandler","emptyCard","DECAY","FACTOR","FSRSAlgorithm","param","s","last_d","last_s","retrievability","g","ivl","enable_fuzz","fuzz_factor","pseudorandom","newInterval","d","next_d","difficulty","init","current","hard_penalty","easy_bound","stability","FSRS","_card","_date","_log","processedCard","recordLog","log","processedLog","last_due","last_lapses","prevCard","reset_count","scheduled_days","forget_log","recordLogItem","cards","options","next_ivl","processCard","new_due","fsrs","params"],"mappings":"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"}